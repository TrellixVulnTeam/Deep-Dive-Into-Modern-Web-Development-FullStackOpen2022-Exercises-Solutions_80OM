{"ast":null,"code":"function objectsEquality(first, second) {\n  \"use strict\"; // If the value of either variable is empty\n  // we can instantly compare them and check\n  // for equality.\n\n  if (first === null || first === undefined || second === null || second === undefined) {\n    return first === second;\n  } // If neither are empty, we can check if\n  // their constructors are equal. Because\n  // constructors are objects, if they are\n  // equal, we know the objects are of the\n  // same type (though not necessarily of\n  // the same value).\n\n\n  if (first.constructor !== second.constructor) {\n    return false;\n  } // If we reach this point, we know both\n  // objects are of the same type so all\n  // we need to do is check what type one\n  // of the objects is, and then compare\n  // them\n\n\n  if (first instanceof Function || first instanceof RegExp) {\n    return first === second;\n  } // Throught back to the equlity check\n  // we started with. Just incase we are\n  // comparing simple objects.\n\n\n  if (first === second || first.valueOf() === second.valueOf()) {\n    return true;\n  } // If the value of check we saw above\n  // failed and the objects are Dates,\n  // we know they are not Dates because\n  // Dates would have equal valueOf()\n  // values.\n\n\n  if (first instanceof Date) return false; // If the objects are arrays, we know\n  // they are not equal if their lengths\n  // are not the same.\n\n  if (Array.isArray(first) && first.length !== second.length) {\n    return false;\n  } // If we have gotten to this point, we\n  // need to just make sure that we are\n  // working with objects so that we can\n  // do a recursive check of the keys and\n  // values.\n\n\n  if (!(first instanceof Object) || !(second instanceof Object)) {\n    return false;\n  } // We now need to do a recursive check\n  // on all children of the object to\n  // make sure they are deeply equal\n\n\n  var firstKeys = Object.keys(first); // Here we just make sure that all the\n  // object keys on this level of the\n  // object are the same.\n\n  var allKeysExist = Object.keys(second).every(function (i) {\n    return firstKeys.indexOf(i) !== -1;\n  }); // Finally, we pass all the values of our\n  // of each object into this function to\n  // make sure everything matches\n\n  var allKeyValuesMatch = firstKeys.every(function (i) {\n    return areTheseObjectsEqual(first[i], second[i]);\n  });\n  return allKeysExist && allKeyValuesMatch;\n}\n\nexport default objectsEquality;","map":{"version":3,"names":["objectsEquality","first","second","undefined","constructor","Function","RegExp","valueOf","Date","Array","isArray","length","Object","firstKeys","keys","allKeysExist","every","i","indexOf","allKeyValuesMatch","areTheseObjectsEqual"],"sources":["C:/Users/Samim Qeya/Documents/Workspace/Full Stack Open 2022/part-2/thephonebook/src/objectsEquality.js"],"sourcesContent":["function objectsEquality(first, second) {\r\n    \"use strict\";\r\n  \r\n    // If the value of either variable is empty\r\n    // we can instantly compare them and check\r\n    // for equality.\r\n    if (\r\n      first === null ||\r\n      first === undefined ||\r\n      second === null ||\r\n      second === undefined\r\n    ) {\r\n      return first === second;\r\n    }\r\n  \r\n    // If neither are empty, we can check if\r\n    // their constructors are equal. Because\r\n    // constructors are objects, if they are\r\n    // equal, we know the objects are of the\r\n    // same type (though not necessarily of\r\n    // the same value).\r\n    if (first.constructor !== second.constructor) {\r\n      return false;\r\n    }\r\n  \r\n    // If we reach this point, we know both\r\n    // objects are of the same type so all\r\n    // we need to do is check what type one\r\n    // of the objects is, and then compare\r\n    // them\r\n    if (first instanceof Function || first instanceof RegExp) {\r\n      return first === second;\r\n    }\r\n  \r\n    // Throught back to the equlity check\r\n    // we started with. Just incase we are\r\n    // comparing simple objects.\r\n    if (first === second || first.valueOf() === second.valueOf()) {\r\n      return true;\r\n    }\r\n  \r\n    // If the value of check we saw above\r\n    // failed and the objects are Dates,\r\n    // we know they are not Dates because\r\n    // Dates would have equal valueOf()\r\n    // values.\r\n    if (first instanceof Date) return false;\r\n  \r\n    // If the objects are arrays, we know\r\n    // they are not equal if their lengths\r\n    // are not the same.\r\n    if (Array.isArray(first) && first.length !== second.length) {\r\n      return false;\r\n    }\r\n  \r\n    // If we have gotten to this point, we\r\n    // need to just make sure that we are\r\n    // working with objects so that we can\r\n    // do a recursive check of the keys and\r\n    // values.\r\n    if (!(first instanceof Object) || !(second instanceof Object)) {\r\n      return false;\r\n    }\r\n  \r\n    // We now need to do a recursive check\r\n    // on all children of the object to\r\n    // make sure they are deeply equal\r\n    const firstKeys = Object.keys(first);\r\n  \r\n    // Here we just make sure that all the\r\n    // object keys on this level of the\r\n    // object are the same.\r\n    const allKeysExist = Object.keys(second).every(\r\n      i => firstKeys.indexOf(i) !== -1\r\n    );\r\n  \r\n    // Finally, we pass all the values of our\r\n    // of each object into this function to\r\n    // make sure everything matches\r\n    const allKeyValuesMatch = firstKeys.every(i =>\r\n      areTheseObjectsEqual(first[i], second[i])\r\n    );\r\n  \r\n    return allKeysExist && allKeyValuesMatch;\r\n  }\r\n\r\n  export default objectsEquality;"],"mappings":"AAAA,SAASA,eAAT,CAAyBC,KAAzB,EAAgCC,MAAhC,EAAwC;EACpC,aADoC,CAGpC;EACA;EACA;;EACA,IACED,KAAK,KAAK,IAAV,IACAA,KAAK,KAAKE,SADV,IAEAD,MAAM,KAAK,IAFX,IAGAA,MAAM,KAAKC,SAJb,EAKE;IACA,OAAOF,KAAK,KAAKC,MAAjB;EACD,CAbmC,CAepC;EACA;EACA;EACA;EACA;EACA;;;EACA,IAAID,KAAK,CAACG,WAAN,KAAsBF,MAAM,CAACE,WAAjC,EAA8C;IAC5C,OAAO,KAAP;EACD,CAvBmC,CAyBpC;EACA;EACA;EACA;EACA;;;EACA,IAAIH,KAAK,YAAYI,QAAjB,IAA6BJ,KAAK,YAAYK,MAAlD,EAA0D;IACxD,OAAOL,KAAK,KAAKC,MAAjB;EACD,CAhCmC,CAkCpC;EACA;EACA;;;EACA,IAAID,KAAK,KAAKC,MAAV,IAAoBD,KAAK,CAACM,OAAN,OAAoBL,MAAM,CAACK,OAAP,EAA5C,EAA8D;IAC5D,OAAO,IAAP;EACD,CAvCmC,CAyCpC;EACA;EACA;EACA;EACA;;;EACA,IAAIN,KAAK,YAAYO,IAArB,EAA2B,OAAO,KAAP,CA9CS,CAgDpC;EACA;EACA;;EACA,IAAIC,KAAK,CAACC,OAAN,CAAcT,KAAd,KAAwBA,KAAK,CAACU,MAAN,KAAiBT,MAAM,CAACS,MAApD,EAA4D;IAC1D,OAAO,KAAP;EACD,CArDmC,CAuDpC;EACA;EACA;EACA;EACA;;;EACA,IAAI,EAAEV,KAAK,YAAYW,MAAnB,KAA8B,EAAEV,MAAM,YAAYU,MAApB,CAAlC,EAA+D;IAC7D,OAAO,KAAP;EACD,CA9DmC,CAgEpC;EACA;EACA;;;EACA,IAAMC,SAAS,GAAGD,MAAM,CAACE,IAAP,CAAYb,KAAZ,CAAlB,CAnEoC,CAqEpC;EACA;EACA;;EACA,IAAMc,YAAY,GAAGH,MAAM,CAACE,IAAP,CAAYZ,MAAZ,EAAoBc,KAApB,CACnB,UAAAC,CAAC;IAAA,OAAIJ,SAAS,CAACK,OAAV,CAAkBD,CAAlB,MAAyB,CAAC,CAA9B;EAAA,CADkB,CAArB,CAxEoC,CA4EpC;EACA;EACA;;EACA,IAAME,iBAAiB,GAAGN,SAAS,CAACG,KAAV,CAAgB,UAAAC,CAAC;IAAA,OACzCG,oBAAoB,CAACnB,KAAK,CAACgB,CAAD,CAAN,EAAWf,MAAM,CAACe,CAAD,CAAjB,CADqB;EAAA,CAAjB,CAA1B;EAIA,OAAOF,YAAY,IAAII,iBAAvB;AACD;;AAED,eAAenB,eAAf"},"metadata":{},"sourceType":"module"}